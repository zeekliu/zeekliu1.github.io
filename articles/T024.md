## [T024] CF1772E 题解
### Date: 2022.12.20

因为最后的排序随便排，只需 $ 1 $ 次，所以最后染蓝色的人必输。

那么既然两个人都会用最佳策略，所以他们并不会将所有的数都染色，而只会染那些需要重排的数，即位置错误的数。

举个例子：

给定数列 $\{2,4,3,1\}$，

正着排序为：$\{1,2,\colorbox{#00ff00}{3},4\}$

反着排序为：$\{4,3,2,\colorbox{#ffcc00}{1}\}$

按照上面的例子，我们可以发现，对于先手，$3$ 的位置是正确的；对于后手，$1$ 的位置是正确的，他们每个人只需涂 $3$ 个数即可，所以**我们先统计位置正确的数**。

对于每个数，存在 $4$ 种情况：

1. 对于正着排序位置正确
2. 对于反着排序位置正确
3. 对于正着、反着位置都正确
4. 对于正着、反着排序位置都不正确

我们设第一种情况有 $a$ 个数，第二种情况有 $b$ 个数，第三种情况有 $c$ 个数，第四种情况有 $d$ 个数。

则分为以下情况：

> 若 $ a+c+d \le b $，则先手赢。

> 若 $ b+c+d < a $，则后手赢。

> 否则，平局。

为什么呢？

因为谁赢是比较要染成蓝色格子的数量，所以谁需要涂的蓝色格子少，谁就赢，如果一样多，谁涂了最后一格，对方就会将数排序，此时就输了，因此这样就会僵持，打平。

代码：

```cpp
//CF1772E 22.12.20
#include <bits/stdc++.h>
using namespace std;
int _,n,a[500010],cnt1=0,cnt2=0,cnt3=0;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>_;
    while (_--)
    {
        cnt1=0,cnt2=0,cnt3=0;
        cin>>n;
        for (int i=1;i<=n;i++) cin>>a[i];
        for (int i=1;i<=n;i++)
        {
            if (a[i]==i) cnt1++;
            if (a[i]==(n-i+1)) cnt2++;
            if (a[i]!=i && a[i]!=(n-i+1)) cnt3++;
        }
        if (cnt2+cnt3<=cnt1) cout<<"First"<<endl;
        else if (cnt1+cnt3<cnt2) cout<<"Second"<<endl;
        else cout<<"Tie"<<endl;
    }
    exit(0);
}
```
